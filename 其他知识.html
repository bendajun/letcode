<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>知识</title>
  </head>
  <style>
    .wrap {
      padding: 12px;
      height: 600px;
      background: skyblue;
    }
    .title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 20px;
    }
  </style>
  <body>
    <div class="wrap">
      <h3 class="title">1.前端性能优化有哪些</h3>
      <div class="contents">
        
      </div>
    </div>
  </body>
  <script>
/*
  BFC介绍；
    https://www.cnblogs.com/Tian-J-Shuai/p/12420526.html
  requestAnimationFrame
    https://blog.csdn.net/CYL_2021/article/details/131624550
  http和https：
    https://blog.csdn.net/weixin_39589455/article/details/130904398
  http1 http2 http3的区别
    https://blog.csdn.net/edwardwzw/article/details/135482475
    https://blog.csdn.net/weixin_47622005/article/details/136515097
  flex：1 到底什么意思
    https://blog.csdn.net/m0_58875326/article/details/124444419
  TCP协议的三次握手和四次挥手
    https://blog.csdn.net/weixin_73466540/article/details/131404800
  vue和react的diff区别
    https://juejin.cn/post/7318446267033452570?searchId=2024042311032731BCA887AA2E3692304D
  TCP和UDP
    https://mp.weixin.qq.com/s?__biz=MzI5MjY4OTQ2Nw==&mid=2247486945&idx=3&sn=cd8cc3e300222a65346c1bb95fa30fb4&chksm=ec7cceb5db0b47a31ce071042e476015ac2374b36a2b1108ef4272aab04c4c95c09b281f1086&scene=178&cur_album_id=2968599106275246086#rd
    vue
    vite
    react
    js高级
    webpack
    node
    other
    nginx
    算法题
    小程序
*/


/*
2.从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)在浏览器地址栏输入 URL浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤HTTP1.0 提供 Expires，
值为一个绝对时间表示缓存新鲜日期HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间如果资源未缓存，发起新请求如果已缓存，
检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
检验新鲜通常有两个 HTTP 头进行控制Expires和Cache-Control：浏览器解析 URL获取协议，主机，端口，path浏览器组装一个 HTTP（GET）请求报文浏览器获取主机 ip 地址，
过程如下：浏览器缓存本机缓存hosts 文件路由器缓存ISP DNS 缓存DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，
三次握手如下：客户端发送一个 TCP 的SYN=1，Seq=X的包到服务器端口服务器发回SYN=1， ACK=X+1， Seq=Y的响应包客户端发送ACK=Y+1，
 Seq=ZTCP 链接建立后发送 HTTP 请求服务器接受请求并解析，将请求转发到服务程序，
 如虚拟主机使用 HTTP Host 头部判断请求的服务程序服务器检查HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，
 返回304等对应状态码处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作服务器将响应报文通过 TCP 连接发送回浏览器浏览器接收 HTTP 响应，
 然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下：
 主动方发送Fin=1， Ack=Z， Seq= X报文被动方发送ACK=X+1， Seq=Z报文被动方发送Fin=1， ACK=X， Seq=Y报文主动方发送ACK=Y， Seq=X报文浏览器检查响应状态吗：
 是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同如果资源可缓存，
 进行缓存对响应进行解码（例如 gzip 压缩）根据资源类型决定如何处理（假设资源为 HTML 文档）解析 HTML 文档，构件 DOM 树，下载资源，
 构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释构建 DOM 树：Tokenizing：根据 HTML 规范将字符流解析为标记Lexing：
 词法分析将标记转换为对象并定义属性和规则DOM construction：根据 HTML 标记关系将对象组成 DOM 树解析过程中遇到图片、样式表、js 文件，
 启动下载构建CSSOM 树：Tokenizing：字符流转换为标记流Node：根据标记创建节点CSSOM：节点创建 CSSOM 树根据 DOM 树和 CSSOM 树构建渲染树:从 DOM 树的根节点遍历所有可见节点，
 不可见节点包括：1）script,meta这样本身不可见的标签。2)被 css 隐藏的节点，如display: none对每一个可见节点，
 找到恰当的 CSSOM 规则并应用发布可视节点的内容和计算样式js 解析如下：浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，
 此时document.readystate 为 loadingHTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。
 这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，
 他们可以遍历和操作 script 和他们之前的文档内容当解析器遇到设置了async属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，
 但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素当文档完成解析，
 document.readState 变成 interactive所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()浏览器在 Document 
 对象上触发 DOMContentLoaded 事件此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，
 document.readState 变为 complete,window 触发 load 事件显示页面（HTML 解析过程中会逐步显示页面）








 图片懒加载
        将图片地址存储到 data-xxx 属性上,判断图片是否在可视区域(IntersectionObserver)就设置图片 src
        const observer = new IntersectionObserver(callBack) observer.observe(imgRef.value);
        防抖：多次触发只会触发最后一次。节流：一段时间内触发一次
        使用异步和延迟加载js文件，避免js文件阻塞页面渲染，将js文件放到文件页面底部，避免阻塞页面渲染
        压缩HTML、CSS代码体积
        减少HTTP请求次数和请求大小
        使用事件委托，减少事件绑定次数。
        合理使用缓存
        路由懒加载
        keep-alive缓存组件
        使用code splitting将代码进行分割，避免将所有代码打包到一个文件，减少响应体积
        fileLoader和url去处理图片





        200	OK。请求成功，服务器正常返回请求的数据。
        201	Created。成功创建了新的资源。通常在 POST 请求或一些需要创建资源的操作后返回。
        204	No Content。服务器成功处理了请求，但不返回任何内容。通常在不需要返回响应体的 DELETE 请求中使用。
        301	Moved Permanently。永久重定向。请求的资源已被分配了新的 URL。浏览器会自动跳转到新的 URL。
        302	Found。临时重定向。请求的资源已被分配了新的 URL。浏览器会自动跳转到新的 URL，但搜索引擎不会更新链接地址。
        304	Not Modified。客户端的缓存资源仍有效，可以直接使用缓存的版本。
        400	Bad Request。请求无效，服务器无法理解该请求。可能是请求参数缺失、格式错误等问题。
        401	Unauthorized。请求要求身份验证。客户端需要提供有效的身份凭证才能访问资源。
        403	Forbidden。服务器拒绝请求，权限不足。客户端没有访问资源的权限。
        404	Not Found。请求的资源不存在。
        500	Internal Server Error。服务器内部错误，无法完成请求。
        502	Bad Gateway。作为代理或网关的服务器从上游服务器接收到无效的响应。
        503	Service Unavailable。服务器暂时无法处理请求，通常是由于维护或过载造成的。



Vite 是一种快速的现代化前端构建工具，相比传统的打包工具（如 webpack）具有以下优点：
快速的冷启动：使用浏览器原生支持的 ES 模块加载方式，无需预构建和打包，直接在浏览器中运行。这样，在开发过程中保持了快速的冷启动时间，加快了开发反馈速度。
按需编译：Vite 只会编译当前正在编辑的文件，而不是重新构建整个项目。当你保存修改后，只有被修改的文件会被重新编译，
  大大缩短了每次保存的构建时间，提高了开发效率。
真正的模块化热更新：Vite 支持真正的模块级热更新，它通过在开发服务器中搭建一个简单的 WebSocket 服务器，与运行在浏览器中的开发服务之间建立了一个实时的连接。
  这使得只有相关模块发生更改时才会触发热更新，而不会影响其他模块，提供了更快速、可靠的热更新体验。
零配置：Vite 提供了一种零配置的开发体验。它内置了对常见的前端框架（如 Vue、React 和 Preact）的支持，不需要复杂的配置即可开始开发。
  同时，Vite 也提供了可扩展的插件系统，以便进行更高级的定制和配置。
构建速度快：虽然 Vite 在开发过程中不需要进行传统的打包，但它仍然提供了一个生产环境的构建命令。Vite 使用 Rollup 进行构建，
  通过 ESBuild 进行快速的 JavaScript 编译，以及采用了增量构建的方式，使得构建速度非常快。
总的来说，，通过利用浏览器原生支持的特性，加速了项目的冷启动时间和热更新速度，从而提高了开发效率。





双向数据绑定就是：数据劫持 + 发布订阅模式（观察者模式）。

Vue2中在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty把这些属性全部转为 getter/setter。并 劫持各个属性 getter 和 setter，在数据变化时发布消息给订阅者，触发相应的监听回调，而这之间存在几个问题

初始化时需要遍历对象所有 key，如果对象层次较深，性能不好
通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多
Object.defineProperty 无法监听到数组元素的变化，只能通过劫持重写数方法
动态新增，删除对象属性无法拦截，只能用特定 set/delete API 代替
不支持 Map、Set 等数据结构
Vue3中使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。

相对于Object.defineProperty()，有以下特点：

Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。
它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。
Proxy 可以监听数组的变化。





更灵活的响应式系统：Vue 2.x 中响应式系统的核心是 Object.defineProperty，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。Vue 3.x 中使用 Proxy对象重写响应式系统。
更快的渲染速度：Vue3 的编译器生成的渲染函数比 Vue2 生成的更高效。
编译阶段：Vue 2.x 通过标记静态节点，优化 diff 的过程。Vue 3.x中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容。
更小的体积：Vue3 将源码拆分为多个独立的模块，这样就可以按需导入所需的模块，从而减小了整个库的体积。
更好的 TypeScript 支持：Vue3 对 TypeScript 的支持更加友好，内部使用了更先进的 TypeScript 特性，并为其提供了更好的声明文件。
更好的组件系统：比如，Vue3中引入了一个新的 Fragment 组件，它可以替代原来的 template 标签作为根节点
新增了setup组合式API







React 的 diff 算法：
react列表对比采用的是从左到右依次对比的方式（因为fiber链表架构的原因）
React diff 算法会首先比较两棵树的根节点，、节点类型不同，直接删除旧，插入新节点；节点类型相同，继续比较子节点。（核心思想是比较和替换节点）

Vue 的 diff 算法：
vue的列表对比，采用的是两端到中间比对的方式，找到最长的相同子序列。
Vue 会对动态节点进行跟踪，节点在新旧虚拟 DOM 中位置发生变化，Vue 会尽可能地将其移动到新的位置，而不是删除和重新插入节点。（核心思想是移动复用节点）
Vue3里面有静态提升，静态节点直接复用


*/
  </script>
</html>



